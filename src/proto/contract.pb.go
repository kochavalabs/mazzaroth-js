// Code generated by protoc-gen-go. DO NOT EDIT.
// source: contract.proto

package pb

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ContractStatus int32

const (
	// The contract status is either not known or not set.
	ContractStatus_CT_UNKNOWN ContractStatus = 0
	// The contract has been accepted by a node and is in the process of being
	// submitted to the blockchain.
	ContractStatus_CT_ACCEPTED ContractStatus = 1
	// This contract was not accepted by the blockchain.
	ContractStatus_CT_REJECTED ContractStatus = 2
	// The contract has succesfully been added to the blockchain.
	ContractStatus_CT_ACTIVE ContractStatus = 3
	// The contract has been paused by the contract owner.
	ContractStatus_CT_PAUSED ContractStatus = 4
	// The contract has been deactivated by the contract owner.
	ContractStatus_CT_DEACTIVATED ContractStatus = 5
	// This contract does not have a status.
	ContractStatus_CT_NOT_FOUND ContractStatus = 6
)

var ContractStatus_name = map[int32]string{
	0: "CT_UNKNOWN",
	1: "CT_ACCEPTED",
	2: "CT_REJECTED",
	3: "CT_ACTIVE",
	4: "CT_PAUSED",
	5: "CT_DEACTIVATED",
	6: "CT_NOT_FOUND",
}

var ContractStatus_value = map[string]int32{
	"CT_UNKNOWN":     0,
	"CT_ACCEPTED":    1,
	"CT_REJECTED":    2,
	"CT_ACTIVE":      3,
	"CT_PAUSED":      4,
	"CT_DEACTIVATED": 5,
	"CT_NOT_FOUND":   6,
}

func (x ContractStatus) String() string {
	return proto.EnumName(ContractStatus_name, int32(x))
}

func (ContractStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d19debeba7dea55a, []int{0}
}

// Basic information describing a contract that can be executed against.
type Contract struct {
	// Name of the contract. Doesn't need to be unique, just used for convenience.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Bytes array representing the id of the owner, this also happens
	// to be the owner's account public key.
	OwnerId []byte `protobuf:"bytes,2,opt,name=owner_id,json=ownerId,proto3" json:"owner_id,omitempty"`
	// Web assembly bytes of the contract to be deployed.
	WasmBytes            []byte   `protobuf:"bytes,3,opt,name=wasm_bytes,json=wasmBytes,proto3" json:"wasm_bytes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Contract) Reset()         { *m = Contract{} }
func (m *Contract) String() string { return proto.CompactTextString(m) }
func (*Contract) ProtoMessage()    {}
func (*Contract) Descriptor() ([]byte, []int) {
	return fileDescriptor_d19debeba7dea55a, []int{0}
}

func (m *Contract) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Contract.Unmarshal(m, b)
}
func (m *Contract) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Contract.Marshal(b, m, deterministic)
}
func (m *Contract) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Contract.Merge(m, src)
}
func (m *Contract) XXX_Size() int {
	return xxx_messageInfo_Contract.Size(m)
}
func (m *Contract) XXX_DiscardUnknown() {
	xxx_messageInfo_Contract.DiscardUnknown(m)
}

var xxx_messageInfo_Contract proto.InternalMessageInfo

func (m *Contract) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Contract) GetOwnerId() []byte {
	if m != nil {
		return m.OwnerId
	}
	return nil
}

func (m *Contract) GetWasmBytes() []byte {
	if m != nil {
		return m.WasmBytes
	}
	return nil
}

// Contract signed by the owner. Used to verify owner during deployment.
type SignedContract struct {
	// Raw contract bytes serialized. Should be in the format of a Contract
	// message.
	Contract []byte `protobuf:"bytes,1,opt,name=contract,proto3" json:"contract,omitempty"`
	// Hexidecimal signature of the contract bytes signed by the contract owner's
	// private key.
	Signature            []byte   `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SignedContract) Reset()         { *m = SignedContract{} }
func (m *SignedContract) String() string { return proto.CompactTextString(m) }
func (*SignedContract) ProtoMessage()    {}
func (*SignedContract) Descriptor() ([]byte, []int) {
	return fileDescriptor_d19debeba7dea55a, []int{1}
}

func (m *SignedContract) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SignedContract.Unmarshal(m, b)
}
func (m *SignedContract) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SignedContract.Marshal(b, m, deterministic)
}
func (m *SignedContract) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignedContract.Merge(m, src)
}
func (m *SignedContract) XXX_Size() int {
	return xxx_messageInfo_SignedContract.Size(m)
}
func (m *SignedContract) XXX_DiscardUnknown() {
	xxx_messageInfo_SignedContract.DiscardUnknown(m)
}

var xxx_messageInfo_SignedContract proto.InternalMessageInfo

func (m *SignedContract) GetContract() []byte {
	if m != nil {
		return m.Contract
	}
	return nil
}

func (m *SignedContract) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

// A contract that a node has accepted, assigned an ID to, and is attempting
// to deploy to the rest of the blockchain.
type AcceptedContract struct {
	// Unique identifier for the contract, should be a public key using the same
	// signing scheme as accounts.
	ContractId []byte `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// These are the raw bytes received from the original request to process a
	// contract. Although nodes read and inspect contract,  they  don't
	// reseralize them after assigning a contract ID. This is to avoid
	// slight differences in serialization format from invalidating a signature.
	SignedContract       []byte   `protobuf:"bytes,2,opt,name=signed_contract,json=signedContract,proto3" json:"signed_contract,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AcceptedContract) Reset()         { *m = AcceptedContract{} }
func (m *AcceptedContract) String() string { return proto.CompactTextString(m) }
func (*AcceptedContract) ProtoMessage()    {}
func (*AcceptedContract) Descriptor() ([]byte, []int) {
	return fileDescriptor_d19debeba7dea55a, []int{2}
}

func (m *AcceptedContract) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AcceptedContract.Unmarshal(m, b)
}
func (m *AcceptedContract) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AcceptedContract.Marshal(b, m, deterministic)
}
func (m *AcceptedContract) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AcceptedContract.Merge(m, src)
}
func (m *AcceptedContract) XXX_Size() int {
	return xxx_messageInfo_AcceptedContract.Size(m)
}
func (m *AcceptedContract) XXX_DiscardUnknown() {
	xxx_messageInfo_AcceptedContract.DiscardUnknown(m)
}

var xxx_messageInfo_AcceptedContract proto.InternalMessageInfo

func (m *AcceptedContract) GetContractId() []byte {
	if m != nil {
		return m.ContractId
	}
	return nil
}

func (m *AcceptedContract) GetSignedContract() []byte {
	if m != nil {
		return m.SignedContract
	}
	return nil
}

func init() {
	proto.RegisterEnum("pb.ContractStatus", ContractStatus_name, ContractStatus_value)
	proto.RegisterType((*Contract)(nil), "pb.Contract")
	proto.RegisterType((*SignedContract)(nil), "pb.SignedContract")
	proto.RegisterType((*AcceptedContract)(nil), "pb.AcceptedContract")
}

func init() { proto.RegisterFile("contract.proto", fileDescriptor_d19debeba7dea55a) }

var fileDescriptor_d19debeba7dea55a = []byte{
	// 300 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x54, 0x91, 0x51, 0x4f, 0xc2, 0x30,
	0x14, 0x85, 0x1d, 0x20, 0xb2, 0x0b, 0x96, 0xe6, 0x3e, 0xa1, 0xd1, 0x48, 0x78, 0x91, 0xf8, 0xe0,
	0x8b, 0xbf, 0x60, 0x76, 0x35, 0x01, 0x93, 0x41, 0x46, 0x51, 0x1f, 0x4c, 0x9a, 0xb1, 0x35, 0x84,
	0x07, 0xb6, 0x65, 0x2d, 0x21, 0xfe, 0x01, 0x7f, 0xb7, 0x59, 0xd9, 0xa6, 0xbe, 0xf5, 0x7c, 0xb7,
	0xf7, 0x9c, 0x93, 0x5c, 0x20, 0x71, 0x96, 0x9a, 0x22, 0x8a, 0xcd, 0x63, 0x5e, 0x64, 0x26, 0xc3,
	0x56, 0xbe, 0x99, 0x7c, 0x40, 0x8f, 0x55, 0x14, 0x11, 0x3a, 0x69, 0xb4, 0x57, 0x23, 0x67, 0xec,
	0x4c, 0xdd, 0xd0, 0xbe, 0xf1, 0x0a, 0x7a, 0xd9, 0x31, 0x55, 0x85, 0xdc, 0x25, 0xa3, 0xd6, 0xd8,
	0x99, 0x0e, 0xc2, 0x0b, 0xab, 0x67, 0x09, 0xde, 0x02, 0x1c, 0x23, 0xbd, 0x97, 0x9b, 0x2f, 0xa3,
	0xf4, 0xa8, 0x6d, 0x87, 0x6e, 0x49, 0x9e, 0x4b, 0x30, 0x99, 0x03, 0x59, 0xed, 0xb6, 0xa9, 0x4a,
	0x1a, 0xff, 0x6b, 0xe8, 0xd5, 0x0d, 0x6c, 0xc6, 0x20, 0x6c, 0x34, 0xde, 0x80, 0xab, 0x77, 0xdb,
	0x34, 0x32, 0x87, 0x42, 0x55, 0x41, 0xbf, 0x60, 0xf2, 0x09, 0xd4, 0x8b, 0x63, 0x95, 0x9b, 0x3f,
	0x6e, 0x77, 0xd0, 0xaf, 0xb7, 0xcb, 0x72, 0x27, 0x43, 0xa8, 0xd1, 0x2c, 0xc1, 0x7b, 0x18, 0x6a,
	0x5b, 0x40, 0x36, 0xa9, 0x27, 0x63, 0xa2, 0xff, 0xf5, 0x7a, 0xf8, 0x76, 0x80, 0xd4, 0x62, 0x65,
	0x22, 0x73, 0xd0, 0x48, 0x00, 0x98, 0x90, 0xeb, 0xe0, 0x35, 0x58, 0xbc, 0x07, 0xf4, 0x0c, 0x87,
	0xd0, 0x67, 0x42, 0x7a, 0x8c, 0xf1, 0xa5, 0xe0, 0x3e, 0x75, 0x2a, 0x10, 0xf2, 0x39, 0x67, 0x25,
	0x68, 0xe1, 0x25, 0xb8, 0xf6, 0x87, 0x98, 0xbd, 0x71, 0xda, 0xae, 0xe4, 0xd2, 0x5b, 0xaf, 0xb8,
	0x4f, 0x3b, 0x88, 0x40, 0x98, 0x90, 0x3e, 0xb7, 0x73, 0xaf, 0xdc, 0x38, 0x47, 0x0a, 0x03, 0x26,
	0x64, 0xb0, 0x10, 0xf2, 0x65, 0xb1, 0x0e, 0x7c, 0xda, 0xdd, 0x74, 0xed, 0x5d, 0x9e, 0x7e, 0x02,
	0x00, 0x00, 0xff, 0xff, 0x5f, 0x66, 0x20, 0x6c, 0xa9, 0x01, 0x00, 0x00,
}
